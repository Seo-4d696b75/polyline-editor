[{"C:\\Users\\skaor\\Documents\\ekimemo\\ts-test\\src\\reportWebVitals.ts":"1","C:\\Users\\skaor\\Documents\\ekimemo\\ts-test\\src\\index.tsx":"2","C:\\Users\\skaor\\Documents\\ekimemo\\ts-test\\src\\script\\Actions.ts":"3","C:\\Users\\skaor\\Documents\\ekimemo\\ts-test\\src\\components\\Dialog.tsx":"4","C:\\Users\\skaor\\Documents\\ekimemo\\ts-test\\src\\script\\color.ts":"5","C:\\Users\\skaor\\Documents\\ekimemo\\ts-test\\src\\script\\utils.ts":"6","C:\\Users\\skaor\\Documents\\ekimemo\\ts-test\\src\\components\\Map.tsx":"7","C:\\Users\\skaor\\Documents\\ekimemo\\ts-test\\src\\components\\Editor.tsx":"8","C:\\Users\\skaor\\Documents\\ekimemo\\ts-test\\src\\components\\PolylineEdit.ts":"9","C:\\Users\\skaor\\Documents\\ekimemo\\ts-test\\src\\script\\Reducer.ts":"10","C:\\Users\\skaor\\Documents\\ekimemo\\ts-test\\src\\script\\types.ts":"11","C:\\Users\\skaor\\Documents\\ekimemo\\ts-test\\src\\diagram\\utils.ts":"12","C:\\Users\\skaor\\Documents\\ekimemo\\ts-test\\src\\components\\Header.tsx":"13","C:\\Users\\skaor\\Documents\\ekimemo\\ts-test\\src\\components\\App.tsx":"14","C:\\Users\\skaor\\Documents\\ekimemo\\ts-test\\src\\diagram\\Line.ts":"15","C:\\Users\\skaor\\Documents\\ekimemo\\ts-test\\src\\script\\Event.ts":"16","C:\\Users\\skaor\\Documents\\ekimemo\\ts-test\\src\\diagram\\Point.ts":"17","C:\\Users\\skaor\\Documents\\ekimemo\\ts-test\\src\\diagram\\Edge.ts":"18","C:\\Users\\skaor\\Documents\\ekimemo\\ts-test\\src\\script\\Store.ts":"19","C:\\Users\\skaor\\Documents\\ekimemo\\ts-test\\src\\diagram\\types.ts":"20"},{"size":425,"mtime":1609596005201,"results":"21","hashOfConfig":"22"},{"size":491,"mtime":1612596478078,"results":"23","hashOfConfig":"22"},{"size":2282,"mtime":1614522327211,"results":"24","hashOfConfig":"22"},{"size":10950,"mtime":1632126910193,"results":"25","hashOfConfig":"22"},{"size":894,"mtime":1609940945646,"results":"26","hashOfConfig":"22"},{"size":2719,"mtime":1612598892633,"results":"27","hashOfConfig":"22"},{"size":11771,"mtime":1632133704075,"results":"28","hashOfConfig":"22"},{"size":7644,"mtime":1632127373247,"results":"29","hashOfConfig":"22"},{"size":11373,"mtime":1632128696488,"results":"30","hashOfConfig":"22"},{"size":2668,"mtime":1614519091646,"results":"31","hashOfConfig":"22"},{"size":1432,"mtime":1632119308544,"results":"32","hashOfConfig":"22"},{"size":7497,"mtime":1614518311792,"results":"33","hashOfConfig":"22"},{"size":1379,"mtime":1609939284911,"results":"34","hashOfConfig":"22"},{"size":451,"mtime":1614512508065,"results":"35","hashOfConfig":"22"},{"size":3913,"mtime":1614518311761,"results":"36","hashOfConfig":"22"},{"size":885,"mtime":1614507281716,"results":"37","hashOfConfig":"22"},{"size":1684,"mtime":1614518311765,"results":"38","hashOfConfig":"22"},{"size":2987,"mtime":1614518311757,"results":"39","hashOfConfig":"22"},{"size":298,"mtime":1614504722122,"results":"40","hashOfConfig":"22"},{"size":504,"mtime":1614518311788,"results":"41","hashOfConfig":"22"},{"filePath":"42","messages":"43","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"44"},"141b9ne",{"filePath":"45","messages":"46","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"47"},{"filePath":"48","messages":"49","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"50"},{"filePath":"51","messages":"52","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"53","messages":"54","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"50"},{"filePath":"55","messages":"56","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"57"},{"filePath":"58","messages":"59","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"60","messages":"61","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"57"},{"filePath":"62","messages":"63","errorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"64","usedDeprecatedRules":"50"},{"filePath":"65","messages":"66","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"47"},{"filePath":"67","messages":"68","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"69"},{"filePath":"70","messages":"71","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"72","messages":"73","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"74"},{"filePath":"75","messages":"76","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"77","messages":"78","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"79"},{"filePath":"80","messages":"81","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"69"},{"filePath":"82","messages":"83","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"84","messages":"85","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":null},{"filePath":"86","messages":"87","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"69"},{"filePath":"88","messages":"89","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":null},"C:\\Users\\skaor\\Documents\\ekimemo\\ts-test\\src\\reportWebVitals.ts",[],["90","91"],"C:\\Users\\skaor\\Documents\\ekimemo\\ts-test\\src\\index.tsx",[],["92","93"],"C:\\Users\\skaor\\Documents\\ekimemo\\ts-test\\src\\script\\Actions.ts",[],["94","95"],"C:\\Users\\skaor\\Documents\\ekimemo\\ts-test\\src\\components\\Dialog.tsx",[],"C:\\Users\\skaor\\Documents\\ekimemo\\ts-test\\src\\script\\color.ts",[],"C:\\Users\\skaor\\Documents\\ekimemo\\ts-test\\src\\script\\utils.ts",[],["96","97"],"C:\\Users\\skaor\\Documents\\ekimemo\\ts-test\\src\\components\\Map.tsx",[],"C:\\Users\\skaor\\Documents\\ekimemo\\ts-test\\src\\components\\Editor.tsx",[],"C:\\Users\\skaor\\Documents\\ekimemo\\ts-test\\src\\components\\PolylineEdit.ts",["98","99"],"import * as Utils from \"../script/utils\"\r\nimport { PolylineProps, LatLng, EditOption, PointSelector, EditState, EditType } from \"../script/types\"\r\nimport { MapContainer } from \"../components/Map\"\r\nimport * as Action from \"../script/Actions\"\r\n\r\nexport function updateSelectors(this: MapContainer, line: PolylineProps, pos: LatLng) {\r\n\r\n  if (this.state.edit_option) return\r\n  if (!line || line.points.length < 2) return\r\n  // index of closest point\r\n  var i1 = Utils.findClosedIndex(pos, line.points)\r\n  var p1 = line.points[i1]\r\n  switch (this.state.edit_state?.type) {\r\n    case EditType.Extending:\r\n\r\n      // TODO\r\n      break\r\n    case EditType.EdgeFocused:\r\n    case undefined:\r\n      var i2: number = 0\r\n      if (i1 === 0) {\r\n        i2 = 1\r\n      } else if (i1 === line.points.length - 1) {\r\n        i2 = line.points.length - 2\r\n      } else {\r\n        var d1 = Utils.findClosedDist(\r\n          p1,\r\n          line.points[i1 - 1],\r\n          pos\r\n        )\r\n        var d2 = Utils.findClosedDist(\r\n          p1,\r\n          line.points[i1 + 1],\r\n          pos\r\n        )\r\n        i2 = (d1 < d2) ? i1 - 1 : i1 + 1\r\n      }\r\n      // index of next point\r\n      var p2 = line.points[i2]\r\n      if (this.state.edit_state?.type === EditType.EdgeFocused) {\r\n        var value = this.state.edit_state.value\r\n        if (value.start.index === i1 && value.end.index === i2) {\r\n          // no change\r\n          break\r\n        }\r\n      }\r\n      var points: Array<PointSelector> = []\r\n      var dist = Math.sqrt(Math.pow(p1.lat - p2.lat, 2) + Math.pow(p1.lng - p2.lng, 2))\r\n      var zoom = this.map ? this.map.getZoom() : 1\r\n      dist *= Math.pow(2, zoom)\r\n      // no prompt marker shown if too narrow \r\n      if (dist > 40) {\r\n        const click = (marker: google.maps.Marker, self: PointSelector) => {\r\n          showEditOption.call(this, self, \"exist\", marker)\r\n        }\r\n        var i = Math.max(i1, i2)\r\n        var start = {\r\n          position: p1,\r\n          index: i1,\r\n          key: i1,\r\n          line: line,\r\n          onDragStart: (p: LatLng) => { updateEditingLine.call(this, line, i1, p, \"exist\") },\r\n          onDrag: (p: LatLng) => { updateEditingLine.call(this, line, i1, p, \"exist\") },\r\n          onDragEnd: (p: LatLng) => { updatePosition.call(this, line, i1, p, \"exist\") },\r\n          onClick: click\r\n        }\r\n        var middle = {\r\n          position: {\r\n            lat: (p1.lat + p2.lat) / 2,\r\n            lng: (p1.lng + p2.lng) / 2,\r\n          },\r\n          index: i,\r\n          key: (i1 + i2) / 2,\r\n          line: line,\r\n          fillColor: \"#FFFFFF\",\r\n          onDragStart: (p: LatLng) => { updateEditingLine.call(this, line, i, p, \"new\") },\r\n          onDrag: (p: LatLng) => { updateEditingLine.call(this, line, i, p, \"new\") },\r\n          onDragEnd: (p: LatLng) => { updatePosition.call(this, line, i, p, \"new\") },\r\n        }\r\n        var end = {\r\n          position: p2,\r\n          index: i2,\r\n          key: i2,\r\n          line: line,\r\n          onDragStart: (p: LatLng) => { updateEditingLine.call(this, line, i2, p, \"exist\") },\r\n          onDrag: (p: LatLng) => { updateEditingLine.call(this, line, i2, p, \"exist\") },\r\n          onDragEnd: (p: LatLng) => { updatePosition.call(this, line, i2, p, \"exist\") },\r\n          onClick: click\r\n        }\r\n\r\n        this.setState({\r\n          ...this.state,\r\n          edit_state: {\r\n            type: EditType.EdgeFocused,\r\n            value: {\r\n              start: start,\r\n              middle: middle,\r\n              end: end\r\n            }\r\n          }\r\n        })\r\n      }\r\n      break\r\n    default:\r\n  }\r\n}\r\n\r\nfunction updateEditingLine(this: MapContainer, line: PolylineProps, index: number, pos: LatLng, type: \"new\" | \"exist\") {\r\n\r\n  var points: Array<LatLng> = []\r\n  if (type === \"new\") {\r\n    points.push(line.points[index - 1])\r\n    points.push(pos)\r\n    points.push(line.points[index])\r\n  } else if (type === \"exist\") {\r\n    if (index > 0) points.push(line.points[index - 1])\r\n    points.push(pos)\r\n    if (index < line.points.length - 1) points.push(line.points[index + 1])\r\n  }\r\n  /*  not working because setState forces the marker to its original position, and prevents from being dragged\r\n  this.setState(Object.assign({}, this.state, {\r\n    new_line: path,\r\n  }))\r\n  solution: update path points of polyline directly without setState\r\n  */\r\n  const component = this.new_line.current\r\n  if (component) {\r\n    var path = points.map(p => new this.props.google.maps.LatLng(p.lat, p.lng))\r\n    if (component.polyline instanceof google.maps.Polyline) {\r\n      component.polyline.setPath(path)\r\n    } else {\r\n      console.error(\"fail to find google.maps.Polyline in\", component)\r\n    }\r\n  }\r\n}\r\n\r\nexport function updatePosition(this: MapContainer, line: PolylineProps, index: number, pos: LatLng, type: \"new\" | \"exist\") {\r\n\r\n  if (type === \"exist\") {\r\n    line.points[index] = pos\r\n  } else if (type === \"new\") {\r\n    line.points.splice(index, 0, pos)\r\n  }\r\n  line.version += 1\r\n  Action.updateLines()\r\n}\r\n\r\nfunction showEditOption(this: MapContainer, selector: PointSelector, type: \"exist\" | \"extend\", marker: google.maps.Marker) {\r\n  const line = selector.line\r\n  const index = selector.index\r\n  if (type === \"exist\") {\r\n    var terminal = (index === 0 || index === line.points.length - 1)\r\n    this.setState({\r\n      ...this.state,\r\n      edit_option: {\r\n        point: selector,\r\n        line: line,\r\n        marker: marker,\r\n        type: (terminal ? \"exist-terminal\" : \"exist-middle\"),\r\n      },\r\n    })\r\n  } else if (type === \"extend\") {\r\n    this.setState({\r\n      ...this.state,\r\n      edit_option: {\r\n        point: selector,\r\n        line: selector.line,\r\n        marker: marker,\r\n        type: \"extend\",\r\n      },\r\n    })\r\n  } else if (type === \"extend-target\") {\r\n    // TODO\r\n  }\r\n}\r\n\r\nexport function cutPolyline(this: MapContainer, option: EditOption) {\r\n\r\n  const line = option.line\r\n  const name = line.name\r\n  const points = line.points\r\n  const point = option.point\r\n  if (point.index === 0 || point.index === points.length - 1) return\r\n\r\n  console.log(\"cut\", name, `index:${point.index}`)\r\n  Action.updateLines((polylines, factory) => {\r\n    var new_line = factory()\r\n    return polylines.map(l => {\r\n      if (l.key === line.key) {\r\n        line.name = `${name}-1`\r\n        line.version += 1\r\n        line.points = points.filter((p, i) => i <= point.index)\r\n        new_line.name = `${name}-2`\r\n        new_line.points = points.filter((p, i) => i >= point.index)\r\n        return [line, new_line]\r\n      } else {\r\n        return l\r\n      }\r\n    }).flat()\r\n  })\r\n  this.closeEditOption()\r\n}\r\n\r\nexport function deletePoint(this: MapContainer, option: EditOption) {\r\n\r\n  const line = option.line\r\n  const point = option.point\r\n  console.log(\"delete\", line.name, `index:${point.index}`)\r\n  line.points = line.points.filter((p, i) => i !== point.index)\r\n  line.version += 1\r\n  Action.updateLines()\r\n  this.closeEditOption()\r\n}\r\n\r\nexport function startExtending(this: MapContainer, selector: PointSelector) {\r\n  this.setState({\r\n    ...this.state,\r\n    edit_state: {\r\n      type: EditType.Extending,\r\n      value: {\r\n        point: {\r\n          position: selector.position,\r\n          line: selector.line,\r\n          index: selector.index,\r\n          key: selector.key,\r\n          onClick: (marker, self) => { showEditOption.call(this, self, \"extend\", marker) }\r\n        }\r\n      }\r\n    },\r\n    edit_option: null,\r\n  })\r\n}\r\n\r\nexport function updateExtendingPoint(this: MapContainer, pos: LatLng) {\r\n  if (this.state.edit_state?.type === EditType.Extending && !this.state.edit_option) {\r\n    var points = [this.state.edit_state.value.point.position, pos]\r\n    points.push(pos)\r\n    const component = this.new_line.current\r\n    if (component) {\r\n      var path = points.map(p => new this.props.google.maps.LatLng(p.lat, p.lng))\r\n      if (component.polyline instanceof google.maps.Polyline) {\r\n        component.polyline.setPath(path)\r\n      } else {\r\n        console.error(\"fail to find google.maps.Polyline in\", component)\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\nexport function addPointExtending(this: MapContainer, pos: LatLng) {\r\n  if (this.state.edit_state?.type === EditType.Extending && !this.state.edit_option) {\r\n    const selector = this.state.edit_state.value.point\r\n    const index = selector.index\r\n    const line = selector.line\r\n    var next_index = 0\r\n    if (index === 0) {\r\n      line.points.splice(0, 0, pos)\r\n    } else if (index === line.points.length - 1) {\r\n      next_index = line.points.length\r\n      line.points.push(pos)\r\n    } else {\r\n      console.error(\"invalid index:\", index, \"adding a point to line:\", line)\r\n    }\r\n    line.version += 1\r\n    Action.updateLines()\r\n    this.setState({\r\n      ...this.state,\r\n      edit_state: {\r\n        type: EditType.Extending,\r\n        value: {\r\n          point: {\r\n            position: pos,\r\n            index: next_index,\r\n            line: line,\r\n            key: next_index,\r\n            onClick: (marker, self) => { showEditOption.call(this, self, \"extend\", marker) }\r\n          }\r\n        }\r\n      },\r\n      edit_option: null,\r\n    })\r\n  }\r\n}\r\n\r\nexport function completeExtending(this: MapContainer) {\r\n  this.setState({\r\n    ...this.state,\r\n    edit_state: null,\r\n  })\r\n  this.closeEditOption()\r\n}\r\n\r\nexport function deletePointExtending(this: MapContainer) {\r\n  if (this.state.edit_state?.type === EditType.Extending) {\r\n    const selector = this.state.edit_state.value.point\r\n    const line = selector.line\r\n    if (line.points.length <= 2) return\r\n    const index = selector.index\r\n    var next_index = 0\r\n    if (index === 0) {\r\n      line.points.splice(0, 1)\r\n    } else if (index === line.points.length - 1) {\r\n      line.points.splice(line.points.length - 1, 1)\r\n      next_index = line.points.length - 1\r\n    } else {\r\n      console.error(\"invalid index:\", index, \"deleting a point from line:\", line)\r\n    }\r\n    line.version += 1\r\n    Action.updateLines()\r\n    this.setState({\r\n      ...this.state,\r\n      edit_state: {\r\n        type: EditType.Extending,\r\n        value: {\r\n          point: {\r\n            position: line.points[next_index],\r\n            index: next_index,\r\n            line: line,\r\n            key: next_index,\r\n            onClick: (marker, self) => { showEditOption.call(this, self, \"extend\", marker) }\r\n          }\r\n        }\r\n      },\r\n      edit_option: null,\r\n    })\r\n  }\r\n}\r\n\r\n\r\nexport function mergeLine(this: MapContainer, self: PointSelector, target: PointSelector) {\r\n  if (this.state.edit_state?.type === EditType.Extending) {\r\n\r\n    const points = self.line.points\r\n    if (points.length > 1) {\r\n      const line2 = target.line\r\n      var lines = this.props.polylines.filter(line => line.key !== line2.key)\r\n      if (self.index === 0) {\r\n        if (target.index === 0) {\r\n          line2.points.forEach(p => points.splice(0, 0, p))\r\n        } else if (target.index === line2.points.length - 1) {\r\n          line2.points.reverse()\r\n          line2.points.forEach(p => points.splice(0, 0, p))\r\n        }\r\n      } else if (self.index === points.length - 1) {\r\n        if (target.index === 0) {\r\n          line2.points.forEach(p => points.push(p))\r\n        } else if (target.index === line2.points.length - 1) {\r\n          line2.points.reverse()\r\n          line2.points.forEach(p => points.push(p))\r\n        }\r\n      }\r\n      Action.updateLines(lines)\r\n    }\r\n  }\r\n}","C:\\Users\\skaor\\Documents\\ekimemo\\ts-test\\src\\script\\Reducer.ts",[],"C:\\Users\\skaor\\Documents\\ekimemo\\ts-test\\src\\script\\types.ts",[],["100","101"],"C:\\Users\\skaor\\Documents\\ekimemo\\ts-test\\src\\diagram\\utils.ts",[],"C:\\Users\\skaor\\Documents\\ekimemo\\ts-test\\src\\components\\Header.tsx",[],["102","103"],"C:\\Users\\skaor\\Documents\\ekimemo\\ts-test\\src\\components\\App.tsx",[],"C:\\Users\\skaor\\Documents\\ekimemo\\ts-test\\src\\diagram\\Line.ts",["104"],"import * as point from \"./Point\"\nimport * as edge from \"./Edge\"\nimport {Point, Line, Edge, DiagramError} from \"./types\"\n\nclass LineInitError extends DiagramError {\n\tconstructor(mes: string) {\n\t\tsuper(mes)\n\t}\n}\n\nclass LineError extends DiagramError {\n\tconstructor(mes: string, line?: Line) {\n\t\tsuper(line ? `${mes} line:${toString(line)}` : mes)\n\t}\n}\n\nexport function toString(line: Line): string {\n\treturn `{ax+by+c=0 with a:${line.a},b:${line.b},c:${line.c}}`\n}\n\nexport function isLine(p: any): p is Line {\n\treturn p !== null &&\n\t\ttypeof p === \"object\" &&\n\t\ttypeof p.a === \"number\" &&\n\t\ttypeof p.b === \"number\" &&\n\t\ttypeof p.c === \"number\"\n}\n\n/**\n * Gets an instance of a new line. Pairs of argments are; \n * (1) a, b, c: number => a line defined by equation: ax + by + c = 0\n * (2) a, b: Point => a line which goes through the both points\n * @param a \n * @param b \n * @param c \n */\nexport function init(a: number | Point, b: number | Point, c?: number): Line {\n\tif (typeof a === \"number\" && typeof b === \"number\") {\n\t\tif (typeof c === \"number\") {\n\t\t\tif (b === 0) {\n\t\t\t\tif (a === 0) {\n\t\t\t\t\tthrow new LineInitError(\"a = b = 0\")\n\t\t\t\t}\n\t\t\t\treturn {\n\t\t\t\t\ta: 1.0,\n\t\t\t\t\tb: 0.0,\n\t\t\t\t\tc: c / a,\n\t\t\t\t};\n\t\t\t} else {\n\t\t\t\treturn {\n\t\t\t\t\ta: a / b,\n\t\t\t\t\tb: 1.0,\n\t\t\t\t\tc: c / b,\n\t\t\t\t};\n\t\t\t}\n\t\t} else {\n\t\t\treturn {\n\t\t\t\ta: -a,\n\t\t\t\tb: 1.0,\n\t\t\t\tc: -b,\n\t\t\t};\n\t\t}\n\t} else if (point.isPoint(a) && point.isPoint(b)) {\n\t\tif (point.equals(a, b)) {\n\t\t\tthrow new LineInitError(`duplicated point: ${point.toString(a)}`)\n\t\t} else if (a.x === b.x) {\n\t\t\treturn {\n\t\t\t\ta: 1.0,\n\t\t\t\tb: 0.0,\n\t\t\t\tc: -(a.x + b.x) / 2,\n\t\t\t};\n\t\t} else {\n\t\t\treturn {\n\t\t\t\ta: (b.y - a.y) / (a.x - b.x),\n\t\t\t\tb: 1.0,\n\t\t\t\tc: (b.x * a.y - a.x * b.y) / (a.x - b.x),\n\t\t\t};\n\t\t}\n\t}\n\tthrow new LineInitError(`cannot get an instance with a:${a} b:${b} c:${c}`)\n}\n\n/**\n * Check if a point is located on the given line. \n * (1) a: Line, b: Point => whether point 'b' is located on line 'a' \n * (2) a: Point, b :Point, c: Point => whether point 'c' is located on a line connecting two points 'a' and 'b'\n * @param {line/point} a \n * @param {point} b \n * @param {point} c \n */\nexport function onLine(a: Line | Point, b: Point, c?: Point): boolean {\n\tif (isLine(a) && point.isPoint(b)) {\n\t\tvar line = a;\n\t\tvar p = b;\n\t\treturn Math.abs(line.a * p.x + line.b * p.y + line.c) === 0;\n\t}\n\tif (point.isPoint(a) && point.isPoint(b) && point.isPoint(c)) {\n\t\tvar v = (b.x - a.x) * (c.y - a.y) - (b.y - a.y) * (c.x - a.x);\n\t\treturn v === 0;\n\t}\n\tthrow new LineError(\"invalid arguments\")\n}\n\nexport function equals(l1: Line, l2: Line): boolean {\n\treturn l1.a === l2.a && l1.b === l2.b && l1.c === l2.c;\n}\n\nexport function getIntersection(l1: Line, l2: Line | Edge): Point | null {\n\tif (edge.isEdge(l2)) {\n\t\t// l1:Line l2:edge\n\t\tvar line = l1;\n\t\tvar e = l2;\n\t\tif ((line.a * e.a.x + line.b * e.a.y + line.c) * (line.a * e.b.x + line.b * e.b.y + line.c) <= 0) {\n\t\t\tl2 = edge.toLine(e);\n\t\t} else {\n\t\t\treturn null;\n\t\t}\n\t}\n\t// l1:Line l2:Line\n\tvar det = l1.a * l2.b - l2.a * l1.b;\n\tif (det === 0) {\n\t\treturn null;\n\t} else {\n\t\treturn {\n\t\t\tx: (l1.b * l2.c - l2.b * l1.c) / det,\n\t\t\ty: (l2.a * l1.c - l1.a * l2.c) / det,\n\t\t};\n\t}\n}\n\nexport function getPerpendicularBisector(p1: Point | Edge, p2?: Point): Line {\n\tif (edge.isEdge(p1)) {\n\t\t// p1:edge p2:null\n\t\tvar e = p1;\n\t\tp1 = e.a;\n\t\tp2 = e.b;\n\t}\n\tif (p2) {\n\n\t\t// p1,p2:Point\n\t\treturn {\n\t\t\ta: p1.x - p2.x,\n\t\t\tb: p1.y - p2.y,\n\t\t\tc: (-Math.pow(p1.x, 2) - Math.pow(p1.y, 2) + Math.pow(p2.x, 2) + Math.pow(p2.y, 2)) / 2,\n\t\t}\n\t}\n\tthrow new LineError(`invalid arguments p1:${p1},p2:${p2}`)\n}\n\nexport function getDistance(line: Line, point: Point): number {\n\treturn Math.abs(point.x * line.a + point.y * line.b + line.c) / Math.sqrt(line.a * line.a + line.b * line.b);\n}\n\nexport function onSameSide(line: Line, p1: Point, p2: Point): boolean {\n\tvar v1 = line.a * p1.x + line.b * p1.y + line.c;\n\tvar v2 = line.a * p2.x + line.b * p2.y + line.c;\n\treturn v1 * v2 >= 0;\n}\n","C:\\Users\\skaor\\Documents\\ekimemo\\ts-test\\src\\script\\Event.ts",[],"C:\\Users\\skaor\\Documents\\ekimemo\\ts-test\\src\\diagram\\Point.ts",[],"C:\\Users\\skaor\\Documents\\ekimemo\\ts-test\\src\\diagram\\Edge.ts",["105"],"C:\\Users\\skaor\\Documents\\ekimemo\\ts-test\\src\\script\\Store.ts",[],"C:\\Users\\skaor\\Documents\\ekimemo\\ts-test\\src\\diagram\\types.ts",["106"],{"ruleId":"107","replacedBy":"108"},{"ruleId":"109","replacedBy":"110"},{"ruleId":"107","replacedBy":"111"},{"ruleId":"109","replacedBy":"112"},{"ruleId":"107","replacedBy":"113"},{"ruleId":"109","replacedBy":"114"},{"ruleId":"107","replacedBy":"115"},{"ruleId":"109","replacedBy":"116"},{"ruleId":"117","severity":1,"message":"118","line":2,"column":60,"nodeType":"119","messageId":"120","endLine":2,"endColumn":69},{"ruleId":"117","severity":1,"message":"121","line":47,"column":11,"nodeType":"119","messageId":"120","endLine":47,"endColumn":39},{"ruleId":"107","replacedBy":"122"},{"ruleId":"109","replacedBy":"123"},{"ruleId":"107","replacedBy":"124"},{"ruleId":"109","replacedBy":"125"},{"ruleId":"126","severity":1,"message":"127","line":6,"column":2,"nodeType":"128","messageId":"129","endLine":8,"endColumn":3},{"ruleId":"126","severity":1,"message":"127","line":18,"column":2,"nodeType":"128","messageId":"129","endLine":20,"endColumn":3},{"ruleId":"126","severity":1,"message":"127","line":42,"column":2,"nodeType":"128","messageId":"129","endLine":44,"endColumn":3},"no-native-reassign",["130"],"no-negated-in-lhs",["131"],["130"],["131"],["130"],["131"],["130"],["131"],"@typescript-eslint/no-unused-vars","'EditState' is defined but never used.","Identifier","unusedVar","'points' is assigned a value but never used.",["130"],["131"],["130"],["131"],"@typescript-eslint/no-useless-constructor","Useless constructor.","MethodDefinition","noUselessConstructor","no-global-assign","no-unsafe-negation"]